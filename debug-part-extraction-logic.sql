SET PAGESIZE 100
SET LINESIZE 300
SET FEEDBACK OFF
SET HEADING ON

PROMPT ============================================================
PROMPT Root Cause Analysis: PART_ Node Children Not Being Extracted
PROMPT ============================================================

PROMPT
PROMPT === Check if nodes exist in both COLLECTION_ and PART_ ===
SELECT
    'Node ID' AS CHECK_TYPE,
    'In COLLECTION_' AS IN_COLLECTION,
    'In PART_' AS IN_PART,
    'Should Extract Children?' AS SHOULD_EXTRACT
FROM DUAL
WHERE 1=0
UNION ALL
SELECT
    '18208744 (COWL_SILL_SIDE)' AS CHECK_TYPE,
    CASE WHEN EXISTS(SELECT 1 FROM DESIGN12.COLLECTION_ WHERE OBJECT_ID=18208744) THEN 'YES' ELSE 'NO' END,
    CASE WHEN EXISTS(SELECT 1 FROM DESIGN12.PART_ WHERE OBJECT_ID=18208744) THEN 'YES' ELSE 'NO' END,
    CASE WHEN EXISTS(SELECT 1 FROM DESIGN12.COLLECTION_ WHERE OBJECT_ID=18208744) THEN 'YES (in COLLECTION_)' ELSE 'MAYBE (check PART_)' END
FROM DUAL
UNION ALL
SELECT
    '18143953 (PartInstanceLibrary)' AS CHECK_TYPE,
    CASE WHEN EXISTS(SELECT 1 FROM DESIGN12.COLLECTION_ WHERE OBJECT_ID=18143953) THEN 'YES' ELSE 'NO' END,
    CASE WHEN EXISTS(SELECT 1 FROM DESIGN12.PART_ WHERE OBJECT_ID=18143953) THEN 'YES' ELSE 'NO' END,
    CASE WHEN EXISTS(SELECT 1 FROM DESIGN12.COLLECTION_ WHERE OBJECT_ID=18143953) THEN 'YES (in COLLECTION_)' ELSE 'MAYBE (check PART_)' END
FROM DUAL;

PROMPT
PROMPT === Check COWL_SILL_SIDE children that would NOT be extracted ===
PROMPT === (Children in PART_ where parent is also in PART_) ===
SELECT
    r.OBJECT_ID,
    p.NAME_S_,
    cd.NICE_NAME AS CLASS_TYPE,
    cd.TYPE_ID,
    r.SEQ_NUMBER,
    'COWL_SILL_SIDE child' AS PARENT_NODE
FROM DESIGN12.REL_COMMON r
INNER JOIN DESIGN12.PART_ p ON r.OBJECT_ID = p.OBJECT_ID
LEFT JOIN DESIGN12.CLASS_DEFINITIONS cd ON p.CLASS_ID = cd.TYPE_ID
WHERE r.FORWARD_OBJECT_ID = 18208744
  AND NOT EXISTS (SELECT 1 FROM DESIGN12.COLLECTION_ c WHERE c.OBJECT_ID = p.OBJECT_ID)
ORDER BY r.SEQ_NUMBER;

PROMPT
PROMPT === Check PartInstanceLibrary children that would NOT be extracted ===
PROMPT === (Children in PART_ where parent might be PART_) ===
SELECT
    r.OBJECT_ID,
    p.NAME_S_,
    cd.NICE_NAME AS CLASS_TYPE,
    cd.TYPE_ID,
    r.SEQ_NUMBER,
    'PartInstanceLibrary child' AS PARENT_NODE
FROM DESIGN12.REL_COMMON r
INNER JOIN DESIGN12.PART_ p ON r.OBJECT_ID = p.OBJECT_ID
LEFT JOIN DESIGN12.CLASS_DEFINITIONS cd ON p.CLASS_ID = cd.TYPE_ID
WHERE r.FORWARD_OBJECT_ID = 18143953
  AND NOT EXISTS (SELECT 1 FROM DESIGN12.COLLECTION_ c WHERE c.OBJECT_ID = p.OBJECT_ID)
ORDER BY r.SEQ_NUMBER;

PROMPT
PROMPT === Find ALL PART_ nodes with children in PART_ table ===
PROMPT === (These would be missed by current extraction logic) ===
SELECT
    r.FORWARD_OBJECT_ID AS PARENT_ID,
    p_parent.NAME_S_ AS PARENT_NAME,
    cd_parent.NICE_NAME AS PARENT_TYPE,
    COUNT(*) AS CHILD_COUNT
FROM DESIGN12.REL_COMMON r
INNER JOIN DESIGN12.PART_ p_child ON r.OBJECT_ID = p_child.OBJECT_ID
INNER JOIN DESIGN12.PART_ p_parent ON r.FORWARD_OBJECT_ID = p_parent.OBJECT_ID
LEFT JOIN DESIGN12.CLASS_DEFINITIONS cd_parent ON p_parent.CLASS_ID = cd_parent.TYPE_ID
WHERE NOT EXISTS (SELECT 1 FROM DESIGN12.COLLECTION_ c WHERE c.OBJECT_ID = p_child.OBJECT_ID)
  AND r.FORWARD_OBJECT_ID IN (
    SELECT r2.OBJECT_ID
    FROM DESIGN12.REL_COMMON r2
    WHERE r2.FORWARD_OBJECT_ID = 18140190
  )
GROUP BY r.FORWARD_OBJECT_ID, p_parent.NAME_S_, cd_parent.NICE_NAME
ORDER BY CHILD_COUNT DESC;

EXIT;
